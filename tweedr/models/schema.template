<%! from tweedr.lib.text import UpperCamelCase, singular %>\
<%def name="column_args(column)" filter="trim">
    mysql.${repr(column.type)}${', primary_key=True' if column.primary_key else ''}${', unique=True' if column.unique else ''}
</%def>\
'''
This file, schema.py, is generated by reflect.py but may have small manual
modifications. It should only require regeneration when the database schema
changes. It does not provide much past what the following snippet does, except
that it doesn't require database calls to reflect the database on start up.

    class Something(Base):
        __table__ = Table('somethings', metadata, autoload=True)

from schema import (
% for table in metadata.sorted_tables:
    ${singular(UpperCamelCase(table.name))},
% endfor
)
'''

from sqlalchemy import Column
from sqlalchemy.dialects import mysql
from sqlalchemy.ext.declarative import declarative_base

from tweedr.models.metadata import metadata


class BaseMixin(object):
    def __json__(self):
        '''This method serves to both clone the record (copying its values)
        as well as filter out the special sqlalchemy key (_sa_instance_state)
        '''
        return dict((k, v) for k, v in self.__dict__.items() if k != '_sa_instance_state')

    def __unicode__(self):
        type_name = self.__class__.__name__
        pairs = [u'%s=%s' % (k, v) for k, v in self.__json__().items()]
        return u'<{type_name} {pairs}>'.format(type_name=type_name, pairs=u' '.join(pairs))

    def __str__(self):
        return unicode(self).encode('utf-8')

    def __repr__(self):
        return str(self)

Base = declarative_base(metadata=metadata, cls=BaseMixin)
% for table in metadata.sorted_tables:


class ${singular(UpperCamelCase(table.name))}(Base):
    __tablename__ = '${table.name}'
    % for column in table.columns:
    ${column.name} = Column(${column_args(column)})
    % endfor
% endfor
